### Most Asked topics:
- Sorting, searching, divide-and-conquer, dynamic 
 programming/memoization or algorithms linked 
 to a specific data structure. 
 
- Big-O notations (e.g. run time complexity). We 
 recommend discussing or outlining the 
 algorithm you have in mind before writing code.
 
- Algorithm Complexity, Design, & Analysis: It's 
 fairly critical that you understand big-O 
 complexity analysis. Again run some practice 
 problems to get this down in application.
 
- Recursion and using it to find more elegant 
 solutions to problems that can be solved 
 iteratively.
 
- Know how hashtables work. Be able to 
 implement one using only arrays in your favorite 
 language, in about the space of one interview.
 
- Common sorting functions; what kind of input 
 data theyâ€™re efficient on. Think about what 
 efficiency means in terms of runtime/space 
 used. (ie. In exceptional cases insertion-sort or 
 radix-sort are better than generic QuickSort 
 /MergeSort/HeapSort. Don't do bubble-sort. You 
 should know the details of at least one n*log(n) 
 sorting algorithm, preferably two (ie. quicksort & 
 merge sort).
 
- Trees: Know about trees; basic tree 
 construction, traversal and manipulation 
 algorithms. Familiarize yourself with binary 
 trees, n-ary trees, and trie-trees. Be familiar with 
 at least one type of balanced binary tree, 
 whether it's a red/black tree, a splay tree or an 
 AVL tree, and know how it's implemented. 
 Understand tree traversal algorithms: BFS and 
 DFS, and know the difference between inorder, 
 postorder and preorder.
 #### Quick sort
 #### Merge sort
 #### Heap sort
 #### Insertion sort
 #### Radix sort
 #### Binary Tree
 #### Binary search tree
 #### AVL tree
 #### BFS
 #### DFS
